<base href="https://polygit.org/components/">
<link href="polymer/polymer.html" rel="import">
<dom-module id="gtab-app">
<template>
	<style>
	</style>
	<h1>Generalized take and break</h1>
	<p>Game: .<input id="gameInput" type="text" /></p>
	<p>Play vs. computer?<input id="playerTwoInput" type="checkbox" checked/></p>
	<p>Who goes first?</p>
	<form action="">
		<input type="radio" name="firstPlayer" value="computer"/> Computer<br>
		<input type="radio" name="firstPlayer" value="player" checked/> Player
	</form>
	<p>The board is defined as a comma separated list of heap sizes. Example: 4,10,1 is a game board with a pile of 4, a pile of 10, and a pile of 1.</p>
	<p>Define board: <input id="boardInput" type="text" /></p>
	<input id="startButton" type="button" value="Start" on-tap="start"/>
	<template is="dom-repeat" items="[[heaps]]">
	</template>
</template>
<script>
Polymer({
	is: 'gtab-app',
	properties: {
		// This is the take and break game, e.g. ."77".
		_game: {
			type: String,
			value: "",
		},
		// This is the calculated game value sequence.
		_value_sequence: {
			type: Array,
			value: [],
		},
		// This is the board, an array of heaps. The value in each index is the size of the heap.
		_heaps: {
			type: Array,
			value: [],
		},
		// If set to false, the computer will not play.
		_one_player: {
			type: Boolean,
			value: true,
		},
		// These are the possible values that a game of size i can go to, where i is the index into
		// this array.
		_heap_possible_values: {
			type: Array,
			value: [],
		}
	},
	start: function() {
		var tb_input = this.$.gameInput.value;
		var game = this.parse_game(tb_input);
		var csv_str = this.$.boardInput.value;
		var board = this.make_board(csv_str);
		var one_player = this.$.playerTwoInput.checked;
		if (game && board) {
			this._game = game;
			this._heaps = board;
			this._one_player = one_player;
			if(this._one_player) {
				var max_heap_size = Math.max.apply(null, board);
				if (max_heap_size) {
					var sequence = this.calculate_sequence(max_heap_size, this._game);
					if (sequence) {
						this._value_sequence = sequence;
						var first_player_selector = document.querySelector('input[name="firstPlayer"]:checked');
						if (first_player_selector && first_player_selector.value) {
							if(first_player_selector.value === "computer") {
								this.make_move();
							}
						}
					}
					else {
						console.error("Sequence was not defined correctly.");
						return;
					}
				}
			}
		}
		else {
			console.error("Something went wrong... please try again.");
			return;
		}
	},
	make_move: function() {
	},
	// Checks if the input for the game is valid, if so returns true, if not returns false.
	parse_game: function(tb_input) {
		// If the input is the empty string we return false.
		if (tb_input.length === 0) {
			console.error("Invalid game: empty string.");
			return false;
		}
		// Ignores leading period.
		if (tb_input[0] === '.') {
			tb_input = tb_input.substring(1);
		}
		// If the value includes anything other than numbers 0-7 or is the empty string we return false.
		if ((/[^0-7]/).test(tb_input)) {
			console.error("Invalid game: numbers greater than 7 are not supported.");
			return false;
		}
		return tb_input;
	},
	// Takes a comma separated string, and turns it into an array of ints.
	make_board: function(csv_str) {
		if(csv_str.length === 0) {
			console.error("Invalid board: no board defined.");
			return false;
		}
		// Checks if the array includes any illegal characters.
		if (/[^0-9, ]/.test(csv_str)) {
			console.error("Invalid board: string contains invalid characters.");
			return false;
		}
		var heaps = csv_str.split(',');
		heaps = heaps.map(function(v) {
			v = v.trim();
			if(v.length === 0) {
				return 0;
			}
			return parseInt( v );
		});
		if(heaps.length === 0) {
			console.error("Invalid board: heaps are empty.");
			return false;
		}
		return heaps;
	},
	// Takes distance to calculate and the game definition and returns the sequence up to the
	// largest heap value.
	calculate_sequence: function (max, tb_input) {
		this._heap_possible_values = [];
		// The first value in the sequence is always 0.
		var sequence = [0];
		var n = 1;
	
		// We only build the sequence out to the max heap size because we do not need any more.
		while (n <= max) {
			// We use a set to prevent duplicate values.
			var possible_values = new Set();
			for (var i = 0; i < tb_input.length; i++) {
				// The digit is the value in the game definition at the current index.
				var digit = parseInt(tb_input[i]);
				// k is the number of beans on which we are operating.
				var k = i + 1;
	
				// Whole heap.
				// We check the rightmost bit to make sure we can remove k beans from an entire heap.
				// Then we check if the current heap size is equal to k, which means we can remove the
				// entire current heap. So we add 0 as a possible value (as we take the heap to size 0)
				if (digit & 1 && n === k) {
					possible_values.add(sequence[0]);
				}
	
				// End of heap.
				// We check the middle bit to make sure we can remove k beans from the end of a heap.
				// Then we check if the current heap size minus k is greater than 0. If it isn't, then
				// we cannot remove from the end (which would result in a heap of negative size). We do
				// not check for equality because that is taking an entire heap. If the condition passes
				// we add the game value of the resulting heap size after removing k beans (n-k).
				if (digit & 2 && n - k > 0) {
					possible_values.add(sequence[n - k]);
				}
	
				// Middle of heap.
				// We check the third bit to make sure we can remove k beans from the middle of the
				// heap. We also verify that we would have at least 2 beans left over (n - k >= 2, or
				// n - k > 1 for integers).
				if (digit & 4 && n - k > 1) {
					var a, b;
					// We find all heap sizes a and b such that a + b = (n - k).
					for (var j = 1; j <= (n - k) / 2; j++) {
						a = j;
						b = (n - k) - a;
						// We XOR the nim values at sequence at a and b, and add them to the
						// possible_values set.
						possible_values.add(sequence[a] ^ sequence[b]);
					}
				}
			}

			this._heap_possible_values.push(possible_values);

			var max;
			// We find the maximum game value in the set.
			possible_values.forEach(x => { last = x; });
	
			// If no max was found, the set is empty, and we add 0 to the sequence.
			if(!max) {
				sequence.push(0);
			}
			// If the max is the length of the possible_values set plus one, we know
			// we have all the natrual number from 0 to max, so we add max + 1 to 
			// our sequence.
			else if(max === possible_values.length + 1) {
				sequence.push(max + 1);
			}
			// Else we do mex by finding the smalling excluded game value and push
			// that to the sequence.
			else {
				for (var j = 0; j < max; j++) {
					if (!possible_values.has(j)) {
						sequence.push(j);
						break;
					}
				}
			}
			n++;
		}
		return sequence;
	},
});
</script>
</dom-module>
